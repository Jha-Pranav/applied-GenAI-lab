# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/buddy/backend/tools/manager.ipynb.

# %% auto 0
__all__ = ['ToolManager']

# %% ../../../nbs/buddy/backend/tools/manager.ipynb 1
from typing import List, Dict, Any
from .fs_read import FsReadTool

from .fs_write import FsWriteTool
from .execute_bash import ExecuteBashTool
from .todo import TodoTool
from .debate_agent import DebateAgentTool
from .code_interpreter import CodeInterpreterTool
from .code_quality import CodeQualityTool
from .doc_generator import DocGeneratorTool
from .memory import MemoryManagerTool

# %% ../../../nbs/buddy/backend/tools/manager.ipynb 2
class ToolManager:
    def __init__(self):
        self.tools = {
            "fs_read": FsReadTool(),
            "fs_write": FsWriteTool(),
            "execute_bash": ExecuteBashTool(),
            "todo": TodoTool(),
            "debate_agent": DebateAgentTool(),
            "code_interpreter": CodeInterpreterTool(),
            "code_quality": CodeQualityTool(),
            "doc_generator": DocGeneratorTool(),
            "memory_manager": MemoryManagerTool(),
        }

    def get_tools(self, requested_tools: List[str]) -> List[Dict]:
        """Convert requested tools to OpenAI function calling format."""
        return [self.tools[tool].get_tool_schema() for tool in requested_tools if tool in self.tools]

    def execute_tool(self, tool_name: str, **kwargs) -> Dict[str, Any]:
        """Execute the specified tool with given arguments."""
        if tool_name not in self.tools:
            return {"error": f"Unknown tool: {tool_name}"}
        try:
            return self.tools[tool_name].execute(**kwargs)
        except Exception as e:
            return {"error": f"Tool {tool_name} execution failed: {str(e)}"}
