# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/buddy/backend/core/agent_tools.ipynb.

# %% auto 0
__all__ = ['AgentToolConfig', 'AgentTool', 'AgentOrchestrator']

# %% ../../nbs/buddy/backend/core/agent_tools.ipynb 1
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from .agent import Agent, AgentConfig
from ..tools.base import BaseTool 


# %% ../../nbs/buddy/backend/core/agent_tools.ipynb 2
@dataclass
class AgentToolConfig:
    """Configuration for agent-as-tool"""
    agent_name: str
    description: str
    parameters_schema: Dict[str, Any]
    timeout: int = 60
    max_iterations: int = 3


class AgentTool(BaseTool):
    """Wrapper to use an Agent as a Tool"""
    
    def __init__(self, agent: Agent, config: AgentToolConfig):
        self.agent = agent
        self.config = config
    
    @property
    def name(self) -> str:
        return self.config.agent_name
    
    @property
    def description(self) -> str:
        return self.config.description
    
    @property
    def parameters(self) -> Dict[str, Any]:
        return self.config.parameters_schema
    
    def execute(self, **kwargs) -> Dict[str, Any]:
        """Execute the agent with provided parameters"""
        try:
            # Prepare message for the agent
            message = self._prepare_agent_message(kwargs)
            
            # Run the agent
            result = self.agent.run(message)
            
            return {
                "success": True,
                "agent_name": self.config.agent_name,
                "result": result,
                "message": message
            }
            
        except Exception as e:
            return {
                "success": False,
                "agent_name": self.config.agent_name,
                "error": str(e)
            }
    
    def _prepare_agent_message(self, kwargs: Dict[str, Any]) -> str:
        """Prepare message for the agent based on parameters"""
        # Extract the main task/query
        task = kwargs.get("task") or kwargs.get("query") or kwargs.get("message")
        
        if not task:
            # Build task from all parameters
            param_strings = [f"{k}: {v}" for k, v in kwargs.items()]
            task = f"Process the following parameters: {', '.join(param_strings)}"
        
        return task


class AgentOrchestrator:
    """Orchestrates multiple agents working together"""
    
    def __init__(self):
        self.agents: Dict[str, Agent] = {}
        self.agent_tools: Dict[str, AgentTool] = {}
        self.workflows: Dict[str, List[str]] = {}
    
    def register_agent(self, name: str, agent: Agent, tool_config: Optional[AgentToolConfig] = None):
        """Register an agent and optionally create a tool wrapper"""
        self.agents[name] = agent
        
        if tool_config:
            agent_tool = AgentTool(agent, tool_config)
            self.agent_tools[name] = agent_tool
            
            # Add the agent tool to other agents
            for other_name, other_agent in self.agent.items():
                if other_name != name:
                    other_agent.add_tool(name, agent_tool.execute)
    
    def create_workflow(self, name: str, agent_sequence: List[str]):
        """Create a workflow of agents"""
        self.workflows[name] = agent_sequence
    
    def execute_workflow(self, workflow_name: str, initial_message: str) -> Dict[str, Any]:
        """Execute a predefined workflow"""
        if workflow_name not in self.workflows:
            return {"error": f"Workflow '{workflow_name}' not found"}
        
        sequence = self.workflows[workflow_name]
        results = []
        current_message = initial_message
        
        for agent_name in sequence:
            if agent_name not in self.agents:
                results.append({"error": f"Agent '{agent_name}' not found"})
                continue
            
            agent = self.agents[agent_name]
            result = agent.run(current_message)
            results.append({
                "agent": agent_name,
                "result": result
            })
            
            # Prepare message for next agent
            current_message = self._prepare_next_message(result, current_message)
        
        return {
            "workflow": workflow_name,
            "results": results,
            "final_result": results[-1] if results else None
        }
    
    def _prepare_next_message(self, previous_result: Dict[str, Any], original_message: str) -> str:
        """Prepare message for next agent in workflow"""
        content = previous_result.get("content", "")
        
        next_message = f"Previous agent result: {content}\n\n"
        next_message += f"Original task: {original_message}\n\n"
        next_message += "Continue processing based on the previous result."
        
        return next_message


