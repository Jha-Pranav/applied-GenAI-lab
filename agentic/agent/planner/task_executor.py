# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../nbs/buddy/backend/agents/planner/task_executor.ipynb.

# %% auto 0
__all__ = ['TaskExecutor']

# %% ../../../nbs/buddy/backend/agents/planner/task_executor.ipynb 1
import json
from typing import Optional, List, Tuple
from datetime import datetime
from pathlib import Path
from rich.console import Console

from ..debater import create_debate
from ...tools.introspect import IntrospectTool
from ...tools.base import ToolMetadata, ToolCategory

from agentic.agent.planner.models import (
    Task, ActionStep, ActionResult, IntrospectionResult, 
    TaskExecutionResult, ExecutionStatus
)
from ..introspector import IntrospectAgent

# %% ../../../nbs/buddy/backend/agents/planner/task_executor.ipynb 2
class TaskExecutor:
    """Handles task execution with introspection and retries"""
    
    def __init__(self, agent, console: Console, max_retries: int = 3):
        self.agent = agent
        self.console = console
        self.max_retries = max_retries
        self.introspect_agent = IntrospectAgent(agent, console)
    
    async def execute_task(self, task: Task) -> TaskExecutionResult:
        """Execute all actions in a task with full tracking"""
        start_time = datetime.now()
        self.console.print(f"\nüîÑ Executing Task: {task.name}")
        
        if task.needs_debate:
            self.console.print("üó£Ô∏è Initiating debate for decision making...")
            debate_context = f"Task: {task.description}\nOptions to consider: {', '.join(task.potential_options)}"
            debate_result = await create_debate(topic=task.name, context=debate_context)
            self.console.print(f"Debate result: {debate_result}")
        
        task_result = TaskExecutionResult(
            task_id=task.id,
            task_name=task.name,
            status=ExecutionStatus.IN_PROGRESS,
            execution_time=0.0,
            success_criteria_met=False,
            artifacts_created=[]
        )
        
        overall_success = True
        
        for action in task.actions:
            self.console.print(f"\n  üìå Step {action.step}: {action.purpose}")
            
            action_result, introspection_result = self._execute_action_with_retries(task, action)
            
            task_result.actions_executed.append(action_result)
            if introspection_result:
                task_result.introspection_results.append(introspection_result)
            
            # Update artifacts (ensure it's a list)
            if not isinstance(task_result.artifacts_created, list):
                task_result.artifacts_created = []
                
            artifacts = action_result.artifacts_created
            # Ensure artifacts is always a list
            if not isinstance(artifacts, list):
                if isinstance(artifacts, str):
                    artifacts = [artifacts]
                elif artifacts is None or isinstance(artifacts, bool):
                    artifacts = []
                else:
                    artifacts = [str(artifacts)]
            
            task_result.artifacts_created.extend(artifacts)
            
            if action_result.status != ExecutionStatus.SUCCESS:
                self.console.print(f"  ‚ùå Step {action.step} failed after {self.max_retries} retries")
                overall_success = False
                break
            else:
                self.console.print(f"  ‚úÖ Step {action.step} completed successfully")
        
        # Finalize task result
        end_time = datetime.now()
        task_result.execution_time = (end_time - start_time).total_seconds()
        task_result.status = ExecutionStatus.SUCCESS if overall_success else ExecutionStatus.FAILED
        task_result.success_criteria_met = overall_success
        
        return task_result
    
    def _execute_action_with_retries(self, task: Task, action: ActionStep) -> Tuple[ActionResult, Optional[IntrospectionResult]]:
        """Execute single action with introspection and retries"""
        
        action_result = ActionResult(
            action_id=f"{task.id}_step_{action.step}",
            tool_used="agent",
            result="",
            execution_time=0.0,
            status=ExecutionStatus.PENDING,
            artifacts_created=[]
        )
        
        introspection_result = None
        retry_feedback = ""
        
        for attempt in range(self.max_retries):
            self.console.print(f"    üîÑ Attempt {attempt + 1}/{self.max_retries}")
            
            try:
                start_time = datetime.now()
                
                self.console.print(f"    üöÄ Executing action: {action.purpose}")
                
                result = self._execute_single_action(action, retry_feedback, attempt + 1, retry_feedback)
                
                end_time = datetime.now()
                execution_time = (end_time - start_time).total_seconds()
                
                self.console.print(f"    üì§ Action result length: {len(str(result))} chars")
                self.console.print(f"    üì§ Action result preview: {str(result)[:200]}...")
                
                action_result.result = result
                action_result.execution_time = execution_time
                action_result.status = ExecutionStatus.SUCCESS
                
                new_artifacts = self._detect_new_artifacts()
                action_result.artifacts_created = new_artifacts if isinstance(new_artifacts, list) else []
                
                self.console.print(f"    üìù ActionStep completed in {execution_time:.2f}s")
                if action_result.artifacts_created:
                    if len(action_result.artifacts_created) <= 3:
                        self.console.print(f"    üìÅ New artifacts: {action_result.artifacts_created}")
                    else:
                        shown = action_result.artifacts_created[:3]
                        remaining = len(action_result.artifacts_created) - 3
                        self.console.print(f"    üìÅ New artifacts: {shown} ... (+{remaining} more)")
                else:
                    self.console.print(f"    üìÅ New artifacts: []")
                
                if action.introspect_after:
                    self.console.print(f"    üîç Starting introspection...")
                    introspection_result = self._introspect_action(task, action, result)
                    
                    if introspection_result.success:
                        self.console.print(f"    ‚úÖ Introspection passed (score: {introspection_result.score})")
                        return action_result, introspection_result
                    else:
                        self.console.print(f"    ‚ö†Ô∏è Introspection failed (score: {introspection_result.score})")
                        self.console.print(f"    üí¨ Failure reason: {introspection_result.feedback}")
                        if attempt < self.max_retries - 1:
                            action_result.status = ExecutionStatus.RETRYING
                            retry_feedback = introspection_result.feedback
                            self.console.print(f"    üîÑ Retrying with feedback: {retry_feedback}")
                            continue
                else:
                    self.console.print(f"    ‚è≠Ô∏è Skipping introspection (not required)")
                    return action_result, None
                    
            except Exception as e:
                self.console.print(f"    ‚ùå ActionStep execution error: {e}")
                import traceback
                self.console.print(f"    üìã Full traceback: {traceback.format_exc()}")
                action_result.error_message = str(e)
                action_result.status = ExecutionStatus.FAILED
                
                if attempt < self.max_retries - 1:
                    action_result.status = ExecutionStatus.RETRYING
                    retry_feedback = f"Previous attempt failed with error: {str(e)}"
                    continue
        
        action_result.status = ExecutionStatus.FAILED
        return action_result, introspection_result
    
    def _execute_single_action(self, action: ActionStep, retry_feedback: str = "", attempt: int = 1, validation_error: str = "") -> str:
        """Execute single action using Agent's tool system"""
        
        retry_guidance = ""
        if attempt > 1:
            if attempt == 2:
                retry_guidance = f"""
RETRY GUIDANCE (Attempt {attempt}/3):
Previous attempt failed. Analyze the error and apply targeted corrections while maintaining the same general approach.

FAILURE ANALYSIS:
{validation_error if validation_error else retry_feedback}

CORRECTIVE ACTIONS REQUIRED:
- Address the specific error mentioned above
- Maintain the same tool usage pattern but fix parameter issues
- Ensure all expected outputs are properly created
"""
            elif attempt >= 3:
                retry_guidance = f"""
RETRY GUIDANCE (Attempt {attempt}/3 - FINAL ATTEMPT):
Multiple failures detected. CRITICAL: Switch to alternative approach immediately.

PREVIOUS FAILURES:
{validation_error if validation_error else retry_feedback}

ALTERNATIVE STRATEGY REQUIRED:
- DO NOT repeat the same failing method
- Use different tools or approaches if available
- Simplify the implementation if complexity is causing issues
- Focus on core functionality first, then add features
"""
        
        enriched_prompt = f"""
SYSTEM CONTEXT:
{action.system_prompt}

MISSION OBJECTIVE:
{action.user_prompt}

EXECUTION SPECIFICATION:
‚Ä¢ Primary Goal: {action.purpose}
‚Ä¢ Required Steps: {' ‚Üí '.join(action.sub_steps)}
‚Ä¢ Execution Mode: {action.execution_mode}
‚Ä¢ Quality Standard: Production-grade implementation

{retry_guidance}

{f"PREVIOUS ATTEMPT FEEDBACK: {retry_feedback}" if retry_feedback else ""}

EXECUTION REQUIREMENTS:
1. Use appropriate tools (fs_write, execute_bash, etc.) for file operations
2. Create all expected outputs with proper content and structure
3. Follow best practices for code quality and documentation
4. Ensure error handling and validation where applicable
5. Provide clear, actionable output for verification

TOOL USAGE EXAMPLES:
- fs_write: Use with command="create", path="file.py", file_text="content"
- execute_bash: Use with command="mkdir -p directory" or similar

Execute this action systematically and report detailed results.
"""
        
        result = self.agent.run(enriched_prompt, stream=False, max_iterations=5)
        return result.get("content", "")
    
    def _introspect_action(self, task: Task, action: ActionStep, result: str) -> IntrospectionResult:
        """Use IntrospectAgent to validate action success"""
        
        self.console.print(f"    üîç Starting introspection for step {action.step}")
        
        try:
            task_context = {
                "task_id": task.id,
                "description": task.description,
                "purpose": action.purpose
            }
            
            # Run introspection synchronously
            introspect_result = self.introspect_agent.evaluate_execution(
                task_context=task_context,
                execution_result=result,
                success_criteria=task.success_criteria,
                expected_outputs=task.expected_outputs
            )
            
            self.console.print(f"    üìä Introspection result: {introspect_result}")
            
            if introspect_result and 'overall_score' in introspect_result:
                score = introspect_result['overall_score']
                success = introspect_result.get('success', False)
                feedback = introspect_result.get('feedback_for_retry', 'No feedback provided')
                next_action = introspect_result.get('next_action', 'proceed' if success else 'retry')
                recommendations = introspect_result.get('recommendations', [])
                reasoning = introspect_result.get('reasoning', '')
                
                self.console.print(f"    ‚úÖ Evaluation - Score: {score}, Success: {success}")
                self.console.print(f"    üí≠ Reasoning: {reasoning}")
                
                return IntrospectionResult(
                    success=success,
                    score=score,
                    feedback=feedback,
                    next_action=next_action,
                    recommendations=recommendations
                )
            else:
                self.console.print(f"    ‚ùå Invalid introspection result format")
                
        except Exception as e:
            self.console.print(f"    ‚ö†Ô∏è Introspection error: {e}")
            import traceback
            self.console.print(f"    üìã Full traceback: {traceback.format_exc()}")
        
        return IntrospectionResult(
            success=False,
            score=0.0,
            feedback="Introspection failed - see logs for details",
            next_action="retry",
            recommendations=["Fix introspection system"]
        )
    
    def _detect_new_artifacts(self) -> List[str]:
        """Detect newly created files/artifacts"""
        current_files = set()
        current_dir = Path(".")
        
        exclude_patterns = {
            '.venv', '__pycache__', '.git', 'node_modules', 
            '.pytest_cache', '.mypy_cache', 'execution_cache'
        }
        
        for file_path in current_dir.glob("**/*"):
            if file_path.is_file() and not file_path.name.startswith('.'):
                if any(part in exclude_patterns for part in file_path.parts):
                    continue
                if file_path.suffix in {'.pyc', '.pyo', '.log', '.tmp'}:
                    continue
                current_files.add(str(file_path))
        
        return list(current_files)


