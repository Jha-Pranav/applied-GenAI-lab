# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/buddy/backend/tools.ipynb.

# %% auto 0
__all__ = ['ToolManager']

# %% ../../nbs/buddy/backend/tools.ipynb 1
import os
import json
import subprocess
from typing import Dict, List, Any, Optional
from pathlib import Path

# %% ../../nbs/buddy/backend/tools.ipynb 2
class ToolManager:
    def __init__(self):
        self.tools = {
            "fs_read": self._fs_read,
            "fs_write": self._fs_write,
            "execute_bash": self._execute_bash,
            "introspect": self._introspect,
            "todo": self._todo
        }
        self._task_plans = {}

    def get_tools(self, requested_tools: List[str]) -> List[Dict]:
        """Convert tools to function calling format"""
        available_tools = []
        
        if "fs_read" in requested_tools:
            available_tools.append({
                "type": "function",
                "function": {
                    "name": "fs_read",
                    "description": "Read files, directories, or search for patterns. Use mode='Line' to read file contents, mode='Directory' to list files, mode='Search' to find patterns.",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "operations": {
                                "type": "array",
                                "items": {
                                    "type": "object",
                                    "properties": {
                                        "mode": {
                                            "type": "string", 
                                            "enum": ["Line", "Directory", "Search"],
                                            "description": "Must be exactly 'Line' (read file), 'Directory' (list files), or 'Search' (find pattern)"
                                        },
                                        "path": {"type": "string"},
                                        "pattern": {"type": "string"}
                                    },
                                    "required": ["mode", "path"]
                                }
                            }
                        },
                        "required": ["operations"]
                    }
                }
            })


        if "fs_write" in requested_tools:
            available_tools.append({
                "type": "function",
                "function": {
                    "name": "fs_write",
                    "description": "Create and edit files",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "command": {"type": "string", "enum": ["create", "str_replace", "append"]},
                            "path": {"type": "string"},
                            "file_text": {"type": "string"},
                            "old_str": {"type": "string"},
                            "new_str": {"type": "string"}
                        },
                        "required": ["command", "path"]
                    }
                }
            })

        if "execute_bash" in requested_tools:
            available_tools.append({
                "type": "function",
                "function": {
                    "name": "execute_bash",
                    "description": "Execute bash commands",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "command": {"type": "string"}
                        },
                        "required": ["command"]
                    }
                }
            })


        
        if "introspect" in requested_tools:
            available_tools.append({
                "type": "function",
                "function": {
                    "name": "introspect",
                    "description": "Get CLI capabilities",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "query": {"type": "string"}
                        },
                        "required": ["query"]
                    }
                }
            })
        
        if "todo" in requested_tools:
            available_tools.append({
                "type": "function",
                "function": {
                    "name": "todo",
                    "description": "Break down tasks into steps",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "task": {"type": "string"},
                            "action": {"type": "string", "enum": ["plan", "execute", "status"]}
                        },
                        "required": ["task", "action"]
                    }
                }
            })
        
        return available_tools


    def _fs_read(self, operations: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Read files, directories, or search for patterns"""
        results = []
        
        for op in operations:
            mode = op.get("mode")
            path = op.get("path")
            
            try:
                if mode == "Directory":
                    items = []
                    path_obj = Path(path)
                    if path_obj.exists() and path_obj.is_dir():
                        for item in path_obj.iterdir():
                            items.append({"name": item.name, "type": "directory" if item.is_dir() else "file"})
                    results.append({"path": path, "items": items})
                
                elif mode == "Line":
                    with open(path, 'r') as f:
                        content = f.read()
                    results.append({"path": path, "content": content})
                
                elif mode == "Search":
                    pattern = op.get("pattern", "")
                    matches = []
                    with open(path, 'r') as f:
                        lines = f.readlines()
                    
                    for i, line in enumerate(lines, 1):
                        if pattern.lower() in line.lower():
                            matches.append({"line_number": i, "content": line.strip()})
                    
                    results.append({"path": path, "matches": matches})
                
            except Exception as e:
                results.append({"path": path, "error": str(e)})
        
        return {"results": results}

    def _fs_write(self, command: str, path: str, **kwargs) -> Dict[str, Any]:
        """Write, edit, or modify files"""
        try:
            path_obj = Path(path)
            
            if command == "create":
                file_text = kwargs.get("file_text", "")
                path_obj.parent.mkdir(parents=True, exist_ok=True)
                with open(path, 'w') as f:
                    f.write(file_text)
                return {"success": True, "message": f"Created file: {path}"}
            
            elif command == "append":
                new_str = kwargs.get("new_str", "")
                with open(path, 'a') as f:
                    f.write('\n' + new_str)
                return {"success": True, "message": f"Appended to file: {path}"}
            
            elif command == "str_replace":
                old_str = kwargs.get("old_str", "")
                new_str = kwargs.get("new_str", "")
                
                with open(path, 'r') as f:
                    content = f.read()
                
                new_content = content.replace(old_str, new_str)
                with open(path, 'w') as f:
                    f.write(new_content)
                
                return {"success": True, "message": f"Replaced text in: {path}"}
            
        except Exception as e:
            return {"error": str(e)}

    def _execute_bash(self, command: str) -> Dict[str, Any]:
        """Execute bash commands"""
        try:
            result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=30)
            return {
                "exit_status": result.returncode,
                "stdout": result.stdout,
                "stderr": result.stderr
            }
        except Exception as e:
            return {"error": str(e)}
    
    def _introspect(self, query: str) -> Dict[str, Any]:
        """Provide information about CLI capabilities"""
        return {
            "tools": ["fs_read", "fs_write", "execute_bash", "introspect", "todo"],
            "response": "I can help with file operations, command execution, and task breakdown."
        }
        
    def _todo(self, task: str, action: str) -> Dict[str, Any]:
        """Break down big tasks into smaller chunks"""
        task_hash = str(hash(task))
        
        if action == "plan":
            steps = [
                {"description": "Analyze requirements"},
                {"description": "Create project structure"},
                {"description": "Implement core functionality"},
                {"description": "Add tests and documentation"}
            ]
            self._task_plans[task_hash] = {"task": task, "steps": steps, "completed": []}
            return {"task": task, "steps": steps, "total_steps": len(steps)}
        
        elif action == "execute":
            if task_hash in self._task_plans:
                plan = self._task_plans[task_hash]
                next_step = len(plan["completed"])
                if next_step < len(plan["steps"]):
                    step = plan["steps"][next_step]
                    plan["completed"].append(next_step)
                    return {"step": step, "progress": f"{len(plan['completed'])}/{len(plan['steps'])}"}
            return {"message": "Task not found or completed"}
        
        elif action == "status":
            if task_hash in self._task_plans:
                plan = self._task_plans[task_hash]
                return {"progress": f"{len(plan['completed'])}/{len(plan['steps'])}"}
            return {"error": "Task not found"}
        
        return {"error": "Invalid action"}

    def _break_down_task(self, task: str) -> List[Dict[str, Any]]:
        """Break down a complex task into smaller steps"""
        # Simple heuristic-based task breakdown
        task_lower = task.lower()
        steps = []
        
        # Common patterns for different types of tasks
        if "create" in task_lower and ("app" in task_lower or "application" in task_lower):
            steps = [
                {"type": "fs_write", "description": "Create project directory structure", "action": "setup_project"},
                {"type": "fs_write", "description": "Create main application file", "action": "create_main"},
                {"type": "fs_write", "description": "Create configuration files", "action": "create_config"},
                {"type": "fs_write", "description": "Create requirements/dependencies file", "action": "create_deps"},
                {"type": "execute_bash", "description": "Install dependencies", "action": "install_deps"},
                {"type": "fs_write", "description": "Create basic tests", "action": "create_tests"},
                {"type": "execute_bash", "description": "Run tests to verify setup", "action": "run_tests"}
            ]
        elif "deploy" in task_lower:
            steps = [
                {"type": "fs_write", "description": "Create Dockerfile", "action": "create_dockerfile"},
                {"type": "fs_write", "description": "Create docker-compose.yml", "action": "create_compose"},
                {"type": "execute_bash", "description": "Build Docker image", "action": "build_image"},
                {"type": "execute_bash", "description": "Test container locally", "action": "test_container"},
                {"type": "fs_write", "description": "Create deployment manifests", "action": "create_manifests"},
                {"type": "execute_bash", "description": "Deploy to environment", "action": "deploy"}
            ]
        elif "api" in task_lower:
            steps = [
                {"type": "fs_write", "description": "Create API structure", "action": "create_api_structure"},
                {"type": "fs_write", "description": "Define data models", "action": "create_models"},
                {"type": "fs_write", "description": "Create API endpoints", "action": "create_endpoints"},
                {"type": "fs_write", "description": "Add authentication", "action": "add_auth"},
                {"type": "fs_write", "description": "Create API documentation", "action": "create_docs"},
                {"type": "execute_bash", "description": "Test API endpoints", "action": "test_api"}
            ]
        else:
            # Generic breakdown
            steps = [
                {"type": "fs_read", "description": "Analyze current state", "action": "analyze"},
                {"type": "fs_write", "description": "Create necessary files", "action": "create_files"},
                {"type": "execute_bash", "description": "Execute required commands", "action": "execute_commands"},
                {"type": "fs_read", "description": "Verify results", "action": "verify"}
            ]
        
        return steps

    def _execute_step(self, step: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a single step of a task"""
        step_type = step.get("type")
        description = step.get("description")
        action = step.get("action")
        
        try:
            if step_type == "fs_write":
                # Create a placeholder file or directory based on the action
                if action == "setup_project":
                    self._fs_write("create", "./project/README.md", file_text="# Project\n\nGenerated by todo tool")
                    return {"success": True, "message": "Project structure created"}
                elif action == "create_main":
                    self._fs_write("create", "./project/main.py", file_text="#!/usr/bin/env python3\n# Main application file\n\nif __name__ == '__main__':\n    print('Hello World')")
                    return {"success": True, "message": "Main file created"}
                else:
                    return {"success": True, "message": f"Step '{description}' planned for execution"}
            
            elif step_type == "execute_bash":
                if action == "install_deps":
                    result = self._execute_bash("echo 'Dependencies would be installed here'")
                    return result
                elif action == "run_tests":
                    result = self._execute_bash("echo 'Tests would run here'")
                    return result
                else:
                    return {"success": True, "message": f"Command '{description}' planned for execution"}
            
            elif step_type == "fs_read":
                return {"success": True, "message": f"Analysis step '{description}' completed"}
            
            else:
                return {"success": True, "message": f"Step '{description}' completed"}
                
        except Exception as e:
            return {"error": f"Failed to execute step: {str(e)}"}

