# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/buddy/backend/schemas.ipynb.

# %% auto 0
__all__ = ['ToolCallMode', 'FsReadOperation', 'FsReadParams', 'WriteCommand', 'FsWriteParams', 'ExecuteBashParams',
           'CodeInterpreterParams', 'RepoQualityAnalyzerParams', 'IntrospectAction', 'IntrospectParams',
           'DebateAgentParams', 'DocumentationGeneratorParams', 'MemoryManagerParams', 'TodoAction', 'TodoParams',
           'ToolCall', 'ToolResponse', 'CritiqueResponse', 'QualityAnalysisResponse', 'ComplexityLevel', 'BuddyTool',
           'ExecutionMode', 'Task', 'ExecutionPlan', 'AnalysisResult']

# %% ../../nbs/buddy/backend/schemas.ipynb 1
from pydantic import BaseModel, field_validator, Field
from typing import List, Dict, Any, Optional, Literal
from enum import Enum

# %% ../../nbs/buddy/backend/schemas.ipynb 2
class ToolCallMode(str, Enum):
    LINE = "Line"
    DIRECTORY = "Directory"
    SEARCH = "Search"
    FIND = "Find"
    GREP = "Grep"
    TREE = "Tree"

class FsReadOperation(BaseModel):
    mode: ToolCallMode
    path: str
    pattern: Optional[str] = None
    name_pattern: Optional[str] = None
    file_pattern: Optional[str] = None
    start_line: Optional[int] = 1
    end_line: Optional[int] = -1
    depth: Optional[int] = 1
    max_depth: Optional[int] = 10
    context_lines: Optional[int] = 2
    show_hidden: Optional[bool] = False
    case_sensitive: Optional[bool] = False
    recursive: Optional[bool] = True
    file_type: Optional[Literal["file", "dir", "all"]] = "all"
    smart_chunk: Optional[bool] = True

class FsReadParams(BaseModel):
    operations: List[FsReadOperation]

# %% ../../nbs/buddy/backend/schemas.ipynb 3
class WriteCommand(str, Enum):
    CREATE = "create"
    STR_REPLACE = "str_replace"
    INSERT = "insert"
    APPEND = "append"
    PREPEND = "prepend"
    DELETE_LINES = "delete_lines"
    
class FsWriteParams(BaseModel):
    command: WriteCommand
    path: str
    file_text: Optional[str] = None
    old_str: Optional[str] = None
    new_str: Optional[str] = None
    insert_line: Optional[int] = None
    start_line: Optional[int] = None
    end_line: Optional[int] = None
    create_backup: Optional[bool] = False
    show_diff: Optional[bool] = True
    summary: Optional[str] = None


# %% ../../nbs/buddy/backend/schemas.ipynb 4
class ExecuteBashParams(BaseModel):
    command: str
    working_dir: Optional[str] = None
    timeout: Optional[int] = 30
    env_vars: Optional[Dict[str, str]] = None
    capture_output: Optional[bool] = True
    shell: Optional[str] = "/bin/bash"
    summary: Optional[str] = None


# %% ../../nbs/buddy/backend/schemas.ipynb 5
class CodeInterpreterParams(BaseModel):
    code: str
    language: Optional[Literal["python"]] = "python"
    capture_output: Optional[bool] = True
    save_plots: Optional[bool] = True
    timeout: Optional[int] = 30
    working_dir: Optional[str] = None
    requirements: Optional[List[str]] = None


# %% ../../nbs/buddy/backend/schemas.ipynb 6
class RepoQualityAnalyzerParams(BaseModel):
    repo_path: str
    analysis_type: Optional[Literal["full", "security", "performance", "maintainability", "documentation"]] = "full"
    file_patterns: Optional[List[str]] = None
    exclude_patterns: Optional[List[str]] = None
    severity_threshold: Optional[Literal["low", "medium", "high", "critical"]] = "medium"

# %% ../../nbs/buddy/backend/schemas.ipynb 7
class IntrospectAction(str, Enum):
    CRITIQUE = "critique"
    VALIDATE = "validate"
    REFLECT = "reflect"
    IMPROVE = "improve"

class IntrospectParams(BaseModel):
    action: IntrospectAction
    context: Optional[Dict[str, Any]] = None
    focus_areas: Optional[List[str]] = None



# %% ../../nbs/buddy/backend/schemas.ipynb 8
class DebateAgentParams(BaseModel):
    decision: str
    context: str
    perspectives: Optional[List[str]] = None
    debate_style: Optional[Literal["pros_cons", "alternatives", "devil_advocate", "stakeholder_views"]] = "pros_cons"


# %% ../../nbs/buddy/backend/schemas.ipynb 9
class DocumentationGeneratorParams(BaseModel):
    repo_path: str
    doc_type: Literal["api", "usage", "architecture", "setup", "comprehensive"]
    output_format: Optional[Literal["markdown", "html", "rst"]] = "html"
    include_examples: Optional[bool] = True
    include_diagrams: Optional[bool] = False
    target_audience: Optional[Literal["developers", "users", "contributors"]] = "developers"
    output_path: Optional[str] = "docs"

# %% ../../nbs/buddy/backend/schemas.ipynb 10
class MemoryManagerParams(BaseModel):
    action: Literal["status", "compress", "optimize"]
    messages: Optional[List[Dict[str, Any]]] = None


# %% ../../nbs/buddy/backend/schemas.ipynb 11
class TodoAction(str, Enum):
    PLAN = "plan"
    EXECUTE = "execute"
    STATUS = "status"

class TodoParams(BaseModel):
    task: str
    action: TodoAction
    step_id: Optional[int] = None


# %% ../../nbs/buddy/backend/schemas.ipynb 12
class ToolCall(BaseModel):
    name: str
    parameters: Dict[str, Any]

    @field_validator('parameters')
    @classmethod
    def validate_parameters(cls, args, info):
        tool_name = info.data.get('name')
        
        validation_map = {
            'fs_read': FsReadParams,
            'fs_write': FsWriteParams,
            'execute_bash': ExecuteBashParams,
            'code_interpreter': CodeInterpreterParams,
            'code_quality': RepoQualityAnalyzerParams,
            'doc_generator': DocumentationGeneratorParams,
            'memory_manager': MemoryManagerParams,
            'introspect': IntrospectParams,
            'debate_agent': DebateAgentParams,
            'todo': TodoParams
        }
        
        if tool_name in validation_map:
            validation_map[tool_name](**args)
        
        return args

# %% ../../nbs/buddy/backend/schemas.ipynb 13
class ToolResponse(BaseModel):
    success: bool
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    
class CritiqueResponse(BaseModel):
    overall_assessment: str
    strengths: List[str]
    weaknesses: List[str]
    risks: List[str]
    suggestions: List[str]
    score: int  # 1-10 scale
    
class QualityAnalysisResponse(BaseModel):
    repository: str
    files_analyzed: int
    quality_score: int  # 0-100 scale
    grade: str  # A-F letter grade
    recommendations: List[Dict[str, Any]]
    summary: Dict[str, Any]

# %% ../../nbs/buddy/backend/schemas.ipynb 14
class ComplexityLevel(str, Enum):
    SIMPLE = "simple"
    MODERATE = "moderate"
    COMPLEX = "complex"

class BuddyTool(str, Enum):
    FS_READ = "fs_read"
    FS_WRITE = "fs_write"
    EXECUTE_BASH = "execute_bash"
    CODE_INTERPRETER = "code_interpreter"
    CODE_QUALITY = "code_quality"
    DOC_GENERATOR = "doc_generator"
    MEMORY_MANAGER = "memory_manager"
    INTROSPECT = "introspect"
    DEBATE_AGENT = "debate_agent"
    TODO = "todo"

class ExecutionMode(str, Enum):
    SEQUENTIAL = "sequential"
    PARALLEL = "parallel"

class Task(BaseModel):
    """Buddy-executable task with atomic action steps"""
    id: str = Field(..., description="Unique task identifier")
    name: str = Field(..., description="Task name")
    description: str = Field(..., description="Detailed task description with context and requirements")
    complexity: ComplexityLevel = Field(..., description="Task complexity")
    dependencies: List[str] = Field(default_factory=list, description="Required predecessor tasks")
    buddy_tools: List[BuddyTool] = Field(..., description="Buddy tools needed for this task")
    execution_mode: ExecutionMode = Field(default=ExecutionMode.SEQUENTIAL)
    frameworks: Dict[str, str] = Field(default_factory=dict, description="Specific frameworks/libraries to use")
    actions: List[Dict[str, Any]] = Field(..., description="Atomic action steps with sub-steps")
    success_criteria: str = Field(..., description="How to verify completion")
    expected_outputs: List[str] = Field(default_factory=list, description="Files/artifacts that will be created")

class ExecutionPlan(BaseModel):
    """Buddy execution plan"""
    sequential_phases: List[List[str]] = Field(..., description="Ordered phases of task IDs")
    parallel_groups: List[List[str]] = Field(default_factory=list, description="Tasks that can run in parallel")
    critical_path: List[str] = Field(..., description="Critical sequence of tasks")
    total_actions: int = Field(..., description="Total number of action steps needed")

class AnalysisResult(BaseModel):
    """Complete task analysis for Buddy execution"""
    input_complexity: ComplexityLevel = Field(..., description="Overall complexity")
    recommended_frameworks: Dict[str, str] = Field(..., description="Recommended frameworks/tools by category")
    tasks: List[Task] = Field(..., description="Buddy-executable tasks")
    execution_plan: ExecutionPlan = Field(..., description="Execution strategy")
    buddy_tools_needed: List[BuddyTool] = Field(..., description="All Buddy tools required")
    success_criteria: List[str] = Field(..., description="Project success criteria")

