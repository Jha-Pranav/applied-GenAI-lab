# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/buddy/backend/tools/planner/task_planner.ipynb.

# %% auto 0
__all__ = ['PlannerTool']

# %% ../../nbs/buddy/backend/tools/planner/task_planner.ipynb 1
from typing import Dict, Any
from .base import BaseTool, ToolMetadata, ToolCategory
import concurrent.futures



class PlannerTool(BaseTool):
    """Tool wrapper for DynamicTaskExecutor"""
    
    def __init__(self):
        super().__init__(ToolMetadata(
            name="planner",
            description="Intelligent task planning and execution for complex projects",
            category=ToolCategory.INTELLIGENCE
        ))
    
    def execute(self, request: str) -> Dict[str, Any]:
        """Execute planning and task execution using DynamicTaskExecutor"""
        try:
            import asyncio
            from agentic.agent.planner.executor import DynamicTaskExecutor
            from agentic.core.agent import Agent, AgentConfig
            from rich.console import Console
            # Create agent for executor
            agent_config = AgentConfig(
                name="PlannerAgent",
                instructions="You are a planning agent that breaks down complex tasks."
            )
            agent = Agent(config=agent_config)
            console = Console()
            
            # Execute planning
            executor = DynamicTaskExecutor(agent, console)
            # Check if we're already in an event loop
            try:
                loop = asyncio.get_running_loop()
                # We're in an event loop, create a new thread
                with concurrent.futures.ThreadPoolExecutor() as pool:
                    future = pool.submit(asyncio.run, executor.execute_project(request))
                    result = future.result()
            except RuntimeError:
                # No event loop running, safe to use asyncio.run
                result = asyncio.run(executor.execute_project(request))
            
            return {"success": True, "result": result}
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def get_parameters_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "request": {
                    "type": "string",
                    "description": "The complex project or task to plan and execute"
                }
            },
            "required": ["request"]
        }

